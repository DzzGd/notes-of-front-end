## 浏览器进程与线程
转载自[https://segmentfault.com/a/1190000012925872](https://segmentfault.com/a/1190000012925872)

从用户输入`url`到页面的呈现, 浏览器进过一层层的解析, 但是解析内容非常复杂, 因此如何正确有序执行和各个进程/线程分工非常重要

+ 进程是cpu资源分配的最小单位(是能拥有资源和独立运行的最小单位)
+ 线程是cpu调度的最小单位(线程是建立在进程的基础上的一次程序运行单位, 一个进程中可以有多个线程)

### 浏览器是多进程的

+ 浏览器是`多进程`的
+ 浏览器之所以能够运行, 是因为系统给它的进程分配了资源(cpu. 内存)
+ 简单点理解, 每打开一个Tab页, 就相当于创建了一个`独立的浏览器进程`

### 浏览器都包含哪些进程
1. `Browser进程`: 浏览器的主进程(负责协调. 主控d), 只有一个. 作用有:
   + 负责浏览器界面显示, 与用户交互. 如前进, 后退等
   + 负责各个页面的管理, 创建和销毁其他进程
   + 将Renderer进程得到的内存中的Bitmap, 绘制到用户界面上
   + 网络资源的管理, 下载等
2. 第三方`插件进程`: 每种类型的插件对应一个进程, 仅当使用该插件时才创建
3. `GPU进程`: 最多一个, 用于3D绘制等
4. 浏览器`渲染进程`(浏览器内核)(Renderer进程, 内部是多线程的d): 默认每个Tab页面一个进程, 互不影响. 主要作用为:页面渲染, 脚本执行, 事件处理等

### 浏览器多进程的优势
相比于单进程浏览器, 多进程有如下优点: 

+ 避免单个page crash影响整个浏览器
+ 避免第三方插件crash影响整个浏览器
+ 多进程充分利用`多核优势`
+ 方便使用沙盒模型隔离插件等进程, 提高浏览器稳定性

简单点理解: 如果浏览器是单进程, 那么某个Tab页崩溃了, 就影响了整个浏览器, 体验有多差；同理如果是单进程, 插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势

### 浏览器内核(渲染进程)

可以这样理解, 页面的渲染, JS的执行, 事件的循环, 都在这个进程内进行. 

接下来重点分析这个进程, **浏览器的渲染进程是多线程的**

### 常驻线程

1. GUI渲染线程
   + 负责渲染浏览器界面, 解析HTML, CSS, 构建DOM树和RenderObject树, 布局和绘制等
   + 当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时, 该线程就会执行
   + 注意, **GUI渲染线程与JS引擎线程是互斥的**, 当JS引擎执行时GUI线程会被挂起(相当于被冻结了), GUI更新会被保存在一个队列中`等到JS引擎空闲`时立即被执行
2. JS引擎线程
   + 也称为JS内核, 负责处理Javascript脚本程序(例如V8引擎)
   + JS引擎线程负责解析Javascript脚本, 运行代码
   + JS引擎一直等待着任务队列中任务的到来, 然后加以处理, 一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序
   + 同样注意, GUI渲染线程与JS引擎线程是互斥的, 所以如果JS执行的时间过长, 这样就会造成页面的渲染不连贯, 导致页面渲染加载阻塞
3. 事件触发线程
   + 归属于浏览器而不是JS引擎, 用来控制事件循环(可以理解, JS引擎自己都忙不过来, 需要浏览器另开线程协助)
   + 当JS引擎执行代码块如setTimeOut时(也可来自浏览器内核的其他线程,如鼠标点击. AJAX异步请求等), 会将对应任务添加到事件线程中
   + 当对应的事件符合触发条件被触发时, 该线程会把事件添加到待处理队列的队尾, 等待JS引擎的处理
   + 注意, 由于JS的单线程关系, 所以这些待处理队列中的事件都得排队等待JS引擎处理(当JS引擎空闲时才会去执行)
4. 定时触发器线程
   + 传说中的`setInterval`与`setTimeout`所在线程
   + 浏览器定时计数器并不是由JavaScript引擎计数的,(因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确)
   + 因此通过单独线程来计时并触发定时(计时完毕后, 添加到事件队列中, `等待JS引擎空闲后执行`)
   + 注意, W3C在HTML标准中规定, 规定要求setTimeout中低于4ms的时间间隔算为4ms
5. 异步http请求线程
   + 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   + 将检测到状态变更时, 如果设置有回调函数, 异步线程就产生状态变更事件, 将这个回调再放入事件队列中再由JavaScript引擎执行

![1.png](http://static.bigbigbigdz.xyz:8111/static/img/arti/1dr37l5av245046/1575288299793924744.png)

### 梳理浏览器内核中线程之间的关系

#### GUI渲染线程与JS引擎线程互斥

由于JavaScript是可`操纵DOM`的, 如果在修改这些元素属性`同时`渲染界面(即JS线程和UI线程同时运行), 那么渲染线程前后获得的元素数据就可能不一致了

因此为了防止渲染出现不可预期的结果, 浏览器设置GUI渲染线程与JS引擎为`互斥`的关系, 当JS引擎执行时GUI线程会被`挂起`

GUI更新则会被保存在一个`队列`中等到JS引擎线程空闲时立即被执行

#### JS阻塞页面加载

从上述的互斥关系, 可以推导出, JS如果执行时间过长就会阻塞页面

譬如, 假设JS引擎正在进行`巨量`的计算, 此时就算GUI有更新, 也会被保存到队列中, 等待JS引擎空闲后执行

然后, 由于巨量计算, 所以JS引擎很可能很久很久后才能空闲, 自然会感觉到`巨卡`无比

所以, 要尽量`避免JS执行时间过长`, 这样就会造成页面的渲染不连贯, 导致页面渲染加载阻塞的感觉

#### WebWorker

前文中有提到JS引擎是单线程的, 而且JS执行时间过长会阻塞页面, 那么JS就真的对`cpu密集型`计算无能为力么?

所以, 后来HTML5中支持了`Web Worker`

+ 创建Worker时, JS引擎向浏览器申请开一个`子线程`(子线程是浏览器开的, 完全受主线程控制, 而且不能操作DOM)
+ JS引擎线程与worker线程间通过特定的方式通信(`postMessage API`, 需要通过序列化对象来与线程交互特定的数据)

所以, 如果有非常`耗时`的工作, 请单独开一个Worker线程, 这样里面不管如何翻天覆地都`不会影响`JS引擎`主线程`, 只待计算出结果后, 将结果通信给主线程即可, perfect!

而且注意下, JS引擎是单线程的, 这一点的本质仍然未改变, Worker可以理解是浏览器给JS引擎开的外挂, 专门用来解决那些大量计算问题

**WebWorker与SharedWorker**

既然都到了这里, 就再提一下SharedWorker(避免后续将这两个概念搞混)

+ WebWorker只属于某个页面, 不会和其他页面的Render进程(浏览器内核进程)共享, 所以Chrome在Render进程中(每一个Tab页就是一个render进程)创建一个新的线程来运行Worker中的JavaScript程序

+ SharedWorker是浏览器所有页面共享的, 不能采用与Worker同样的方式实现, 因为它不隶属于某个Render进程, 可以为多个Render进程共享使用, 所以Chrome浏览器为`SharedWorker`单独创建一个`进程`来运行JavaScript程序, 在浏览器中每个相同的JavaScript只存在一个SharedWorker进程, 不管它被创建多少次. 

看到这里, 应该就很容易明白了, 本质上就是进程和线程的区别. SharedWorker由独立的进程管理, WebWorker只是属于render进程下的一个线程

### 浏览器渲染流程

- 浏览器输入`url`, 浏览器主进程接管, 开一个下载线程, 然后进行`http`请求, 然后等待响应, 获取内容, 随后将内容通过RendererHost接口转交给Renderer进程

- 浏览器渲染流程开始

步骤:

1. 解析html建立dom树
2. 解析css构建render树(将CSS代码解析成树形的数据结构, 然后结合DOM合并成render树)
3. 布局render树(Layout/reflow), 负责各元素尺寸、位置的计算
4. 绘制render树(paint), 绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU, GPU会将各层合成(composite), 显示在屏幕上

![2.png](http://static.bigbigbigdz.xyz:8111/static/img/arti/1dr37l5av245046/1575288299793868785.png)


详细过程:

1. 创建Document对象, 开始解析web界面, `document.readyState='loading'`.
2. 遇到link外部css, 创建线程加载, 并继续原线程的解析.
3. 遇到外部js文件, 并`没设有async/defer`的属性, 浏览器正常加载js(阻塞), 等js加载完成再执行下面的内容.
4. 遇到外部js文件, 但是`设有async/defer`的属性, 浏览器创建新的`线程`进行加载, 原线程继续自己的行为.(async是当加载js完毕直接就执行, defer是页面解析完毕后再执行, 异步加载不允许用document.write();
5. 遇到Img, 先正常解析出dom结构, `异步加载src`, 并继续进行解析.
6. 当文档解析完毕`document.readyState="interative"`.
7. 解析完毕之后, 所有设置defer的脚本会按照顺序执行.
8. document对象触发`DOMContentLoaded`事件, 标志程序执行从同步脚本执行阶段转换为事件驱动.
9. 当async的脚本加载并执行后, Img加载完成后, `document.readyState="compete"`.
10. 以异步响应处理网络, 用户操作实行交互.
`window.onload`是在页面解析加载完毕再执行

```javascript
document.addEventListener('DOMContentLoaded',function(){},false)
// DOM解析(document.readyState='interactive')完, 就执行.
```

#### load事件与DOMContentLoaded事件的先后
很简单, 知道它们的定义就可以了:

+ 当 DOMContentLoaded 事件触发时, 仅当DOM加载完成, 不包括样式表, 图片.
(譬如如果有async加载的脚本就不一定完成)

+ 当 `onload` 事件触发时, 页面上所有的DOM, 样式表, 脚本, 图片都已经加载完成了.

所以, 顺序是: `DOMContentLoaded` -> `load`

#### css加载是否会阻塞dom树渲染

这里说的是头部引入css的情况

首先, 我们都知道: **css是由单独的下载线程异步下载的**

然后再说下几个现象: 

+ css加载不会阻塞DOM树解析(异步加载时DOM照常构建)
+ 但会阻塞render树渲染(渲染时需等css加载完毕, 因为render树需要css信息)

这可能也是浏览器的一种优化机制

因为你加载css的时候, 可能会修改下面DOM节点的样式,果css加载不阻塞render树渲染的话, 那么当css加载完之后, `render树`可能又得`重新重绘或者回流`了, 这就造成了一些没有必要的损耗

所以干脆就先把DOM树的结构先解析完, 把可以做的工作做完, 然后等你css加载完之后, 在根据最终的样式来渲染render树, 这种做法性能方面确实会比较好一点